import argparse
import sys
import numpy as np
from clusterlib import read_clustering

p = argparse.ArgumentParser(
    "Applies a clustering to an input file, by selecting the first member of each cluster"
)
p.add_argument("input_file", help="Input file, either a .npy or a text file")
p.add_argument(
    "clustering_file",
    help="Clustering file, e.g. generated by cluster.write_clustering",
)
p.add_argument(
    "output_file",
    help="Output file. Same format as the input file, with the first member of each cluster selected.",
)
p.add_argument(
    "--force",
    action="store_true",
    help="Apply clustering even if the clustering file does not seem to match the input",
)

p.add_argument(
    "--concat",
    action="store_true",
    help="""Instead of selecting just the first cluster member, concatenate input from all cluster members using --sep.
    This is incompatible with numpy arrays. 
    Note that the output remains sorted by the first cluster member, not by cluster rank""",
)

p.add_argument(
    "--sep",
    default="/",
    help="Separator for concatenation using --concat",
)


def err(*args):
    print(*args, file=sys.stderr)
    exit(1)


args = p.parse_args()
is_numpy = False
if args.input_file.endswith(".npy"):
    if args.concat:
        err("--concat is incompatible with numpy arrays")
    is_numpy = True
    inp = np.load(args.input_file)
    kind = "elements"
else:
    inp = []
    with open(args.input_file) as f:
        for l in f.readlines():
            inp.append(l)
    kind = "lines"
clustering = read_clustering(args.clustering_file)
cluster_indices = []
clustering_dict = {}
indices = []
for cnr, c in enumerate(clustering):
    cluster_indices.append(c[0])
    clustering_dict[c[0]] = c
    indices += c
cluster_indices = np.array(cluster_indices, int)
indices = np.array(indices, int)
indices.sort()

if not args.force:
    if indices[0] != 1:
        err("Clustering does not start at 1")
    elif not np.alltrue(indices == np.arange(len(indices)) + 1):
        err("Clustering has missing and/or duplicate indices")

if args.force:
    not_match = indices[-1] > len(inp)
else:
    not_match = indices[-1] != len(inp)
if not_match:
    err(
        f"Clustering does not match input: there are {len(inp)} {kind}, while clustering goes up to {indices[-1]}"
    )

if is_numpy:
    outp = inp[cluster_indices - 1]
    np.save(args.output_file, outp)
else:
    if args.concat:
        outp = []
        for ind in cluster_indices:
            curr_outp = []
            for member in clustering_dict[ind]:
                curr_outp.append(inp[member - 1].rstrip("\n"))
            outp.append(args.sep.join(curr_outp) + "\n")
    else:
        outp = [inp[ind - 1] for ind in cluster_indices]
    with open(args.output_file, "w") as f:
        for l in outp:
            print(l, file=f, end="")
